**GC的算法与种类**
Garbage Collection 垃圾收集
gc的对象是堆空间和永久区

应用计数法
    通过引用计数来回收垃圾:引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，
    则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，
    则对象A就不可能再被使用。
    问题:
        引用和去引用伴随着加减法,影响性能
        无法处理循环引用
标记-清除算法
      标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，
      首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。
      然后，在清除阶段，清除所有未被标记的对象。
标记-压缩算法
      标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。
      和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，
      它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。
复制算法
     将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制
     到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收


可触及的
    从根节点可以触及到这个对象
可复活的
    一旦所有引用被释放，就是可复活状态
    因为在finalize()中可能复活该对象
不可触及的
    在finalize()后，可能会进入不可触及状态
    不可触及的对象不可能复活
    可以回收

根
        栈中引用的对象
        方法区中静态成员或者常量引用的对象（全局对象）
        JNI方法栈中引用对象
Stop-The-World
    Java中一种全局暂停的现象
    全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互
    多半由于GC引起
        Dump线程
        死锁检查
        堆Dump
    问题:
          长时间服务停止，没有响应
            遇到HA系统，可能引起主备切换，严重危害生产环境。
