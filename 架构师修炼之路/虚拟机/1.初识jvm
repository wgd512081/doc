****初识jvm****
java virtual machine
VNMWare
Visual Box
JVM(模拟java字符吗的指令集)

JVM基本结构
PC寄存器:
        每个线程拥有一个pc寄存器
        在线程创建时创建
        指向下一条指令的地址
        执行本地方法时,pc的值为underfined
方法区
        保存装载的类信息
            类型的常量池
            字段,方法信息
            方法字节码
         通常和永久区关联
java堆
        对象
        所有线程共享
        对分代GC来说,堆也是分代的
java栈
        线程私有
        由帧组成
        帧保存一个方法的局部变量(包括对象的引用),操作树栈,常量池指针
        每一次方法调用创建一个帧,并压栈
内存模型:
``      每一个线程有一个工作内存 和主存独立
        工作内存存放主存中变量的值的拷贝

        当数据从主内存复制到工作存储时,必须出现两个动作:
            1:由主内存执行的读(read)操作
            2:由工作内存执行的相应的load操作
        当数据从工作内存拷贝到主内存中时,也执行两个操作:
            1:由工作内存执行的存储(store)操作
            2:由主内存执行相应的写(writer)操作

            每个操作都是原子的,不会被中断

可见性
        一个线程改变了变量,其他线程可以立即知道
        保证可见性的方法:
            1:volatile
            2:synchronized(unlock之前,写变量值回主内存)
            3:final(一旦初始化完成,其他线程就可见)
有序性
        在本线程内,操作都是有序的
        在线程外观察,操作都是无序的(指令重排序或主内存同步延迟)
指令重排
        编译器会根据系统执行的性能对执行顺序进行重排序(单线程不会影响结果)
        但是编译器不考虑多线程间的语义,即多线程会受到重排序的影响
        可重排序:  a=1;b=2;
        不可重排序:a=1;a=2;
        保证有序性的方法:synchronized

       指令重排的基本原则:
          程序顺序原则：一个线程内保证语义的串行性
          volatile规则：volatile变量的写，先发生于读
          锁规则：解锁(unlock)必然发生在随后的加锁(lock)前
          传递性：A先于B，B先于C 那么A必然先于C
          线程的start方法先于它的每一个动作
          线程的所有操作先于线程的终结（Thread.join()）
          线程的中断（interrupt()）先于被中断线程的代码
          对象的构造函数执行结束先于finalize()方法

解释运行
        解释执行以解释方式运行字节码
        解释执行的意思是：读一句执行一句
编译运行（JIT）
        将字节码编译成机器码
        直接执行机器码
        运行时编译
        编译后性能有数量级的提升


























