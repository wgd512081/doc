一级缓存：是SQlSession级别的缓存。在操作数据库时需要构造SqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的SqlSession之间的缓存数据区域（HashMap）是互相不影响的。

第一次发起查询用户ID为1的用户时，依然先去找缓存中是否有相应的用户信息，没有，才从数据库查询。得到用户信息后，将信息存储到一级缓存中。这期间SqlSession执行了一次commit操作，清空了SqlSession中的一级缓存，这样做的目的是为了让缓存中的数据总是最新的数据，避免脏读。之后，再次进行第二查询用户ID为1的用户信息时，依然是先从缓存中查找，没有，所以执行了sql查询语句，从数据库中获取了最新的数据。另外，当SqlSession关闭时，也会清空一级缓存。



 二级缓存：是mapper级别的缓存，多个SqlSession去操作同一个mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

 <settings>
 	<!-- 开启二级缓存 -->
 	<setting name="cacheEnabled" value="true"/>
 </settings>

在一级缓存中也提到过，当我们对数据库进行增删改的时候，数据库数据就进行了修改，这时任何缓存中的数据都需要被清楚，以免造成数据库的查询出现脏读。所以我们需要在每一次的insert、update、delete操作后都进行缓存刷新（即清空），也就是在Statement配置中配置flushCache属性，如下：

<insertid="insertUser" parameterType="cn.itcast.mybatis.po.User"flushCache="true">


一级缓存：（本地缓存），sqlsession级别的缓存，一级缓存一直是开启的
与数据库同一次回话期间查询到的数据会放在本地缓存中，如果获取相同的数据，直接从缓存中拿，不会查询数据库

创建SqlSession(DefaultSqlSession)，然后由SqlSession中的Executor（BaseExecutor）执行查询操作，执行查询之前会先把当前查询的mapper文件路径、查询语句的方法名称和传入的参数存入CacheKey中（唯一判断），开始数据库查询之前会先从map中查询当前CacheKey是否有数据，如果有就从map里面获取，没有的话执行查询操作，并将查询到的数据存入缓存map里面。执行增删改之前都会先调用清空map的方法。


一级缓存失效的情况：
1、sqlSession不同
2,、sqlSession相同，但是查询条件不同
3、sqlSession相同，两次查询之间执行了增删改操作
4、sqlSession相同，手动清除了一级缓存（缓存清空）

二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存：
		工作机制：
		1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；
		2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容；
			不同namespace查出的数据会放在自己对应的缓存中（map）
			效果：数据会从二级缓存中获取
				查出的数据都会被默认先放在一级缓存中。
				只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中


因此MyBatis二级缓存的生命周期即整个应用的生命周期，应用不结束，定义的二级缓存都会存在在内存中。

从这个角度考虑，为了避免MyBatis二级缓存中数据量过大导致内存溢出，MyBatis在配置文件中给我们增加了很多配置例如size（缓存大小）、flushInterval（缓存清理时间间隔）、eviction（数据淘汰算法）来保证缓存中存储的数据不至于太过庞大。


使用MyBatis二级缓存有一个前提：必须保证所有的增删改查都在同一个命名空间下才行。